<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Telegram Mesh Signaling ‚Äì FINAL FIX</title>

<script src="https://cdn.jsdelivr.net/npm/simple-peer@9/simplepeer.min.js"></script>

<style>
body {
  font-family: monospace;
  background:#020617;
  color:#e5e7eb;
  padding:16px;
}
button,input {
  width:100%;
  margin:6px 0;
  padding:8px;
}
pre {
  background:#020617;
  border:1px solid #334155;
  padding:10px;
  height:260px;
  overflow:auto;
  white-space:pre-wrap;
}
</style>
</head>

<body>

<h3>üåê Telegram Mesh Signaling (FINAL FIX)</h3>

<button onclick="createOffer()">‚ûï CREATE OFFER</button>
<input id="msg" placeholder="message">
<button onclick="broadcast()">SEND MESSAGE</button>

<pre id="log"></pre>

<script>
/* ================= CONFIG ================= */
const BOT_SEND   = "BOT_SENDER_TOKEN";
const BOT_READ   = "BOT_READER_TOKEN";
const CHANNEL_ID = "-100XXXXXXXXXX";

/* ================= STATE ================= */
const myId = "anom" + Math.floor(Math.random()*9999);
let lastUpdateId = 0;

/*
state = {
  connId: {
    initiator: SimplePeer | null,
    peers: { fromId: SimplePeer }
  }
}
*/
const state = {};
const processed = new Set();

/* ================= UI ================= */
const logEl = document.getElementById("log");
function log(m){
  logEl.textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
log("üÜî myId = " + myId);

/* ================= TELEGRAM ================= */
async function sendEvent(evt){
  log(`üì§ SEND ‚Üí ${evt.kind} ${evt.connId}`);
  try {
    const r = await fetch(
      `https://api.telegram.org/bot${BOT_SEND}/sendMessage`,
      {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body:JSON.stringify({
          chat_id: CHANNEL_ID,
          text: JSON.stringify(evt)
        })
      }
    );
    const j = await r.json();
    log("üì® TELEGRAM RESP: " + (j.ok ? "OK" : JSON.stringify(j)));
  } catch(e){
    log("‚ùå TELEGRAM ERROR: " + e.message);
  }
}

async function pollEvents(){
  try {
    const r = await fetch(
      `https://api.telegram.org/bot${BOT_READ}/getUpdates?offset=${lastUpdateId+1}`
    );
    const j = await r.json();
    if(!j.result) return;

    for(const u of j.result){
      lastUpdateId = u.update_id;
      const msg = u.channel_post || u.message;
      if(!msg?.text) continue;

      try {
        const evt = JSON.parse(msg.text);
        reducer(evt);
      } catch {}
    }
  } catch(e){
    log("‚ùå POLL ERROR: " + e.message);
  }
}

/* ================= REDUCER ================= */
function reducer(e){
  if(e.from === myId) return;
  if(Date.now() - e.ts > 180000) return;

  const key = e.from + "_" + e.connId + "_" + e.kind;
  if(processed.has(key)) return;
  processed.add(key);

  const { kind, connId, from } = e;

  if(kind === "offer"){
    if(!state[connId]) state[connId] = { initiator:null, peers:{} };
    if(state[connId].peers[from]) return;

    log(`üì• OFFER ${connId} from ${from}`);

    const p = new SimplePeer({ initiator:false, trickle:false });
    state[connId].peers[from] = p;

    setupPeer(p, connId, from);
    p.signal(e.payload);
  }

  if(kind === "answer"){
    const s = state[connId];
    if(!s?.initiator) return;
    if(s.peers[from]) return;

    log(`üì• ANSWER ${connId} from ${from}`);

    const p = new SimplePeer({ initiator:true, trickle:false });
    s.peers[from] = p;

    setupPeer(p, connId, from);
    p.signal(s.offer);
    p.signal(e.payload);
  }
}

/* ================= PEER ================= */
function setupPeer(peer, connId, remoteId){
  peer.on("signal", data=>{
    if(data.type === "offer"){
      state[connId].offer = data;
    }

    sendEvent({
      v:1,
      kind: data.type,
      from: myId,
      to: "*",
      connId,
      ts: Date.now(),
      payload: data
    });
  });

  peer.on("connect", ()=>{
    log(`‚úÖ CONNECTED ${connId} ‚Üî ${remoteId || "peer"}`);
  });

  peer.on("data", d=>{
    log(`üí¨ ${remoteId || "peer"}: ${d}`);
  });

  peer.on("close", ()=>{
    log(`‚ö†Ô∏è CLOSED ${connId}`);
  });

  peer.on("error", e=>{
    log(`‚ùå PEER ERROR ${connId}: ${e.message}`);
  });
}

/* ================= ACTION ================= */
function createOffer(){
  const connId = "conn-" + crypto.randomUUID();
  log(`‚è≥ CREATE OFFER ${connId}`);

  const p = new SimplePeer({ initiator:true, trickle:false });
  state[connId] = { initiator:p, peers:{}, offer:null };

  setupPeer(p, connId, null);

  // üî• WAJIB: trigger negotiation (mobile/iOS safe)
  setTimeout(()=>{
    try {
      p.send("__init__");
      log("‚ö° negotiation triggered");
    } catch {}
  }, 50);
}

function broadcast(){
  const t = msg.value.trim();
  if(!t) return;

  for(const cid in state){
    for(const pid in state[cid].peers){
      const p = state[cid].peers[pid];
      if(p.connected) p.send(myId + ": " + t);
    }
  }
}

/* ================= LOOP ================= */
setInterval(pollEvents, 1500);
</script>

</body>
</html>