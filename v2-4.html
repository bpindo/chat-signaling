<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Telegram Mesh Signaling FINAL</title>

<script src="https://cdn.jsdelivr.net/npm/simple-peer@9/simplepeer.min.js"></script>

<style>
body { font-family: monospace; background:#0f172a; color:#e5e7eb; padding:16px }
button,input { width:100%; margin:6px 0; padding:8px }
pre { background:#020617; padding:10px; height:220px; overflow:auto }
</style>
</head>
<body>

<h3>üåê Telegram Mesh Signaling (FINAL)</h3>

<button onclick="createOffer()">‚ûï Create Offer</button>
<input id="msg" placeholder="message">
<button onclick="broadcast()">Send Message</button>

<pre id="log"></pre>

<script>
/* ================= CONFIG ================= */
const BOT_SEND   = "BOT_SENDER_TOKEN";
const BOT_READ   = "BOT_READER_TOKEN";
const CHANNEL_ID = "-100XXXXXXXXXX";

/* ================= STATE ================= */
const myId = "anom" + Math.floor(Math.random()*9999);
let lastUpdateId = 0;

/*
state = {
  connId: {
    initiator: SimplePeer | null,
    peers: {
      fromId: SimplePeer
    }
  }
}
*/
const state = {};

const logEl = document.getElementById("log");
const log = m => { logEl.textContent += m + "\n"; logEl.scrollTop = logEl.scrollHeight; };

/* ================= TELEGRAM ================= */
async function sendEvent(evt){
  await fetch(`https://api.telegram.org/bot${BOT_SEND}/sendMessage`,{
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body:JSON.stringify({
      chat_id: CHANNEL_ID,
      text: JSON.stringify(evt)
    })
  });
}

async function pollEvents(){
  const r = await fetch(
    `https://api.telegram.org/bot${BOT_READ}/getUpdates?offset=${lastUpdateId+1}`
  );
  const j = await r.json();
  if(!j.result) return;

  for(const u of j.result){
    lastUpdateId = u.update_id;
    const msg = u.channel_post || u.message;
    if(!msg?.text) continue;

    try {
      const evt = JSON.parse(msg.text);
      reducer(evt);
    } catch {}
  }
}

/* ================= REDUCER ================= */
function reducer(e){
  if(e.from === myId) return;
  if(Date.now() - e.ts > 180000) return;

  const { kind, connId, from } = e;

  if(kind === "offer"){
    if(!state[connId]) state[connId] = { initiator:null, peers:{} };
    if(state[connId].peers[from]) return;

    log(`üì• OFFER ${connId} from ${from}`);

    const p = new SimplePeer({ initiator:false, trickle:false });
    state[connId].peers[from] = p;

    setupPeer(p, connId, from, "receiver");
    p.signal(e.payload);
  }

  if(kind === "answer"){
    const s = state[connId];
    if(!s?.initiator) return;
    if(s.peers[from]) return;

    log(`üì• ANSWER ${connId} from ${from}`);

    s.peers[from] = true;
    s.initiator.signal(e.payload);
  }
}

/* ================= PEER ================= */
function setupPeer(peer, connId, remoteId, role){

  peer.on("signal", data=>{
    sendEvent({
      v:1,
      kind: data.type,
      connId,
      from: myId,
      to: "*",
      ts: Date.now(),
      payload: data
    });
  });

  peer.on("connect", ()=>{
    log(`‚úÖ CONNECTED ${connId} ‚Üî ${remoteId || "peer"}`);
  });

  peer.on("data", d=>{
    log(`üí¨ ${remoteId || "peer"}: ${d}`);
  });

  peer.on("close", ()=>{
    log(`‚ö†Ô∏è CLOSED ${connId}`);
  });
}

/* ================= ACTION ================= */
function createOffer(){
  const connId = "conn-" + crypto.randomUUID();
  const p = new SimplePeer({ initiator:true, trickle:false });

  state[connId] = { initiator:p, peers:{} };
  setupPeer(p, connId, null, "initiator");

  log(`üì§ OFFER CREATED ${connId}`);
}

function broadcast(){
  const t = msg.value.trim();
  if(!t) return;

  for(const cid in state){
    const s = state[cid];
    if(s.initiator?.connected) s.initiator.send(myId+": "+t);
  }
}

/* ================= LOOP ================= */
setInterval(pollEvents, 1500);
log("üÜî myId: " + myId);
</script>

</body>
</html>