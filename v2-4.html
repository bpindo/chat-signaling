<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Telegram Mesh Signaling ‚Äì Optimized</title>

<script src="https://cdn.jsdelivr.net/npm/simple-peer@9/simplepeer.min.js"></script>

<style>
body{
  font-family:monospace;
  background:#f4f7fb;
  padding:16px;
}
button,input{
  width:100%;
  padding:10px;
  margin:6px 0;
}
pre{
  background:#0f172a;
  color:#9ef;
  padding:10px;
  height:220px;
  overflow:auto;
}
</style>
</head>

<body>

<h3>üåê Telegram Mesh ‚Äì Optimized v1</h3>

<button onclick="createOffer()">‚ûï BUAT OFFER (AUTO SEND)</button>

<input id="msg" placeholder="Pesan">
<button onclick="broadcast()">üì§ KIRIM PESAN</button>

<pre id="log"></pre>

<script>
/* ================= BOT INFO ================= */
const BOT_SEND = "8384730708:AAHjPCLYpW7wz2B5-jBxMJ17-kH1G1zXZuY";
const BOT_READ = "359218339:AAF7KH-T3ihEPvHfWPJge_Ax9PdV9GQw2W0";
const CHANNEL_ID = "-1003689025820";

/* ================= STATE ================= */
const myId = "peer-" + Math.random().toString(36).slice(2,8);
const peers = {};
const state = {};
let lastUpdateId = 0;
const seenSignals = new Set();

/* ================= UI ================= */
const logEl = document.getElementById("log");
function log(m){
  logEl.textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}
log("üÜî myId = " + myId);

/* ================= TELEGRAM ================= */
async function sendToTelegram(obj){
  await fetch(`https://api.telegram.org/bot${BOT_SEND}/sendMessage`,{
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body:JSON.stringify({
      chat_id: CHANNEL_ID,
      text: JSON.stringify(obj)
    })
  });
}

async function pollTelegram(){
  try{
    const r = await fetch(
      `https://api.telegram.org/bot${BOT_READ}/getUpdates?offset=${lastUpdateId+1}`
    );
    const j = await r.json();
    if(!j.result) return;

    for(const u of j.result){
      lastUpdateId = u.update_id;
      const m = u.channel_post || u.message;
      if(!m?.text) continue;

      /* FILTER KETAT */
      if(!m.text.startsWith("{")) continue;
      if(!m.text.includes('"signal"')) continue;

      if(seenSignals.has(m.text)) continue;
      seenSignals.add(m.text);
      if(seenSignals.size > 200) seenSignals.clear();

      const e = JSON.parse(m.text);
      handleEvent(e);
    }
  }catch(e){
    log("‚ùå POLL ERR " + e.message);
  }
}

/* ================= CORE LOGIC ================= */
function handleEvent(e){
  if(e.from === myId) return;
  if(Date.now() - e.ts > 120000) return;

  const cid = e.connId;

  if(e.kind === "offer"){
    if(state[cid]) return;
    if(e.claimedBy && e.claimedBy !== myId) return;

    log("üì• OFFER " + cid);

    const p = new SimplePeer({initiator:false,trickle:false});
    setupPeer(p,cid,"receiver");
    p.signal(e.payload.sdp);

    /* CLAIM OFFER */
    sendToTelegram({
      ...e,
      claimedBy: myId
    });
  }

  if(e.kind === "answer"){
    if(state[cid]?.role !== "initiator") return;
    log("üì• ANSWER " + cid);
    state[cid].peer.signal(e.payload.sdp);
  }
}

/* ================= PEER ================= */
function setupPeer(peer,connId,role){
  peers[connId] = peer;
  state[connId] = { peer, role };

  peer.on("signal",data=>{
    sendToTelegram({
      v:1,
      kind:data.type,
      from:myId,
      connId,
      ts:Date.now(),
      payload:{ sdp:data }
    });
    log("üì° SIGNAL " + data.type + " " + connId);
  });

  peer.on("connect",()=>{
    log("‚úÖ CONNECTED " + connId);
  });

  peer.on("data",d=>{
    log("üí¨ " + d);
  });

  peer.on("close",()=>{
    cleanup(connId);
  });
}

function cleanup(id){
  if(peers[id]){
    peers[id].destroy();
    delete peers[id];
    delete state[id];
  }
}

/* ================= ACTION ================= */
function createOffer(){
  const connId = "conn-" + crypto.randomUUID();
  const p = new SimplePeer({initiator:true,trickle:false});
  setupPeer(p,connId,"initiator");
  log("‚è≥ CREATE OFFER " + connId);
}

function broadcast(){
  const t = document.getElementById("msg").value;
  for(const id in peers){
    if(peers[id].connected){
      peers[id].send(myId + ": " + t);
    }
  }
}

/* ================= POLLING ================= */
function pollInterval(){
  return Object.keys(peers).length === 0 ? 2500 : 15000;
}

(function loop(){
  pollTelegram();
  setTimeout(loop, pollInterval());
})();
</script>

</body>
</html>